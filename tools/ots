#!/bin/bash

# Need this earlier to source local scripts
SCRIPT_DIR="$( 
 cd "$(dirname "$(readlink "$0" || printf %s "$0")")"
 pwd -P 
)"


# Bash defines HOSTNAME but it's possible that it might not be a FQDN, this specifically enforces that it will be
HOSTNAME="$(hostname -f)"

if [ "x$THIS_HOST" == "x" ]; then
	THIS_HOST="${HOSTNAME}"
fi


if [ "x$OTS_USER_STUB" == "x" ]; then
	OTS_USER_STUB="${USER}"
fi

# Get color code variables and other common utility portions of the code
source "${SCRIPT_DIR}"/common.sh ots

function setupTrace() 
{	

	if [ "x$OTS_DISABLE_TRACE_DEFAULT" == "x" ]; then
		rm /tmp/trace_buffer_${OTS_USER_STUB}
	fi

	# trace helper functions
	source "${TRACE_BIN}"/trace_functions.sh
	
	#source /data/ups/setup
	#setup TRACE v3_13_04
	#ups active
	#which trace_cntl
	#type toffS

	
	#for muting trace
	export TRACE_NAME=OTSDAQ_TRACE
	export TRACE_LIMIT_MS="0,50,50" #unlimited trace messages
	#tinfo #show trace info

	if [ "x$OTS_DISABLE_TRACE_DEFAULT" == "x" ]; then
		export TRACE_FILE=/tmp/trace_buffer_${OTS_USER_STUB} #by default it is /proc/trace/buffer		
	fi

	export TRACE_PRINT_FD=2 #reroute everything to std:err (overriding > dev/null hiding)
	export TRACE_PRINT="|%L:%N:%f [%u] %m" #to mimic ots line number output
}

setupTrace

# Handle SIGHUP which likely means the ssh connection starting ots was closed and we want to continue with outputs redirected
handler () {
	exec >/dev/null 2>&1 </dev/null
}
# Install the redirection
trap 'handler' HUP
 
# Enable core dumps, by default the soft limit on size is 0, preventing any. Raising it to unlimited before launch specifically
# enables coredumps for any process run from this point onward in this script
ulimit -c unlimited


STARTTIME=`date +"%d%h%y.%T"` #to fully ID one StartOTS from another

#export products, used by artdaq daqInterface
export OTS_PRODUCTS=`echo $PRODUCTS|tr ':' '\n'|grep -v localProducts|head -1`
export XDAQ_CONFIGURATION_XML=otsConfiguration_CMake_Run #used by xdaq supervisors to write context xml


#############################
# setup defaults:
KILLALL=0
ISMACROMAKER=0
ISFINDLOGFILES=0
ISCONFIG=0
QUIET=1
CHROME=0
FIREFOX=0
BACKUPLOGS=0
RELAUNCHCHECK=1
REMOTELAUNCH=1
ISREMOTE=0
MACROMAKER_MODE=0
export MACROMAKER_MODE #this environment variable is used by source code 
#############################

# Output startup banner

if [ "$1" != "-x" ]; then

	if [ "x$OTS_OWNER" == "x" ]; then
		out "Consider setting the OTS_ONWER enviroment variable to your project name..."
		out "${Green}=========================== ots ============================="
		OTS_OWNER=${USER}
	else
		out "${Green}=========================== ${OTS_OWNER} ots ============================="
	fi
	
fi

# Check for options
while :; do
	case "$1" in
	--macromaker | -mm)
		# Match macro-maker mode
		info "MACRO-MAKER ONLY MODE!"
		ISMACROMAKER=1
		;;
	--config | --configure | --wizard | --wiz | -w | --config | --configure)
		# Matches all the different ways that wiz mode can be specified
		info "WIZ MODE ENABLED!"
		ISCONFIG=1
		;;
	--verbose | -v)
		# Enable verbose mode (disable quiet mode)
		info "VERBOSE MODE ENABLED!"
		QUIET=0
		;;
	--logfind | -l)
		# Printout the potential location of all log files based on current xdaq xml launch configuration
		info "DISPLAYING LOG FILE LOCATIONS!"
		ISFINDLOGFILES=1
		;;
	--chrome | -c)
		# Enable launching chrome after startup
		info "CHROME LAUNCH ENABLED!"
		CHROME=1
		;;
	--firefox | -f)
		# Enable launching firefox after startup
		info "FIREFOX LAUNCH ENABLED!"
		FIREFOX=1
		;;
	--backup | -b)
		# Enable backing up of logs before overwriting them?
		info "BACKUP LOGS ENABLED"
		BACKUPLOGS=1
		;;
	--relaunch | -r)
		# Disable relaunching functionality
		info "RELAUNCH CHECK DISABLED!"
		RELAUNCHCHECK=0
		;;
	--startremote | -s)
		# Disable launching on remote nodes (this flag primarily used for instances when launched from the main gateway)
		info "REMOTE START PROPAGATION DISABLED!"
		REMOTELAUNCH=0
		;;
	--isremote | -x)
		# Reduce printouts vs mode where remote start propagation is disabled, though same behavior
		#info "REMOTE START PROPAGATION DISABLED!"
		REMOTELAUNCH=0
		ISREMOTE=1
		;;
	--killall | --kill | --kx | -k)
		info "KILL OTS!"
		KILLALL=1
		;;
	--)
		# Match '--' which is traditionally used to seperate option flags from program arguments that might start with
		# a '-' character
		shift
		break
		;;
	-*)
		# Match any option starting with '-' that isn't matched by any of the previous rules and alert the user to it
		# not being handled
		
		out
		out "******************************************************"
		out "*************        ots Usage          **************"
		out "******************************************************"	
		out
		out "To kill all otsdaq running processes, please use any of these options:"
		out "--killall  --kill  --kx  -k"
		out "	e.g.: ots --kx"
		out
		out "To start otsdaq in 'wiz mode' please use any of these options:"
		out "--configure  --config  --wizard  --wiz  -w"
		out "	e.g.: ots --wiz"
		out
		out "To start otsdaq with 'verbose mode' enabled, add one of these options:"
		out "--verbose  -v"
		out "	e.g.: ots --wiz -v     or    ots --verbose"
		out
		out "To display potential log file locations based on current otsdaq configuration, add one of these options:"
		out "--logfind  -l"
		out "	e.g.: ots -l     or    ots --logfind"
		out
		out "To start otsdaq and launch google-chrome, add one of these options:"
		out "--chrome  -c"
		out "	e.g.: ots --wiz -c     or    ots --chrome"
		out
		out "To start otsdaq and launch firefox, add one of these options:"
		out "--firefox  -f"
		out "	e.g.: ots --wiz -f     or    ots --firefox"
		out
		out "To backup and not overwrite previous quiet log files, add one of these options:"
		out "--backup  -b"
		out "	e.g.: ots -b     or    ots --backup"
		out
		out "To disable otsdaq startup checking and relaunching, add one of these options:"
		out "--relaunch  -r"
		out "	e.g.: ots -r     or    ots --relaunch"
		out
		out "To disable otsdaq remote process startup, add one of these options:"
		out "--startremote  -s"
		out "	e.g.: ots -s     or    ots --startremote"
		out
		out "Exiting ots. Please see usage tips above."		
		out
		die "Unsupported option '$1'"
		;;
	*)
		# Match any remaining non-option arguments (or an empty string) which marks the end of arguments
		break
		;;
	esac
	shift
done

# TODO: move config down here and output current config if the quiet option isn't set
# (this prevents multiple outputs if people specify a flag twice)

# Setup trace default config if not specifically disabled

# TODO: Trace is handled all over the place, the best place for this is actually in setup_ots.sh since that
# file gets sourced on remote sides so we get a consistent startup environment
if [ "x$OTS_DISABLE_TRACE_DEFAULT" == "x" ]; then
	out "Setting up TRACE defaults..."
	
	#=============================
	#Trace setup and helpful commented lines:
	export TRACE_MSGMAX=0 #Activating TRACE
	
	#echo Turning on all memory tracing via: tonMg 0-63 
	#tonMg 0-63
	#type toffS
	
	#tonSg 0-63 #turn on all slow paths
	
	# turn on err|warn|dbg|trace
	#${TRACE_BIN}/trace_cntl lvlset 0 0x1f 0	
	
	# Default setup moved from setup_trace to here so it can be disabled
##	tonMg 0-4  #enable trace to memory
#	tonSg 0-3  #enable trace to slow path (i.e. UDP)
#	toffSg 4-64 #apparently not turned off by default?
#	${TRACE_BIN}/trace_cntl lvlsetg 0x1f 0 0 # tonMg 0-4
#	${TRACE_BIN}/trace_cntl lvlclrg 0 0xffffffffffffffff 0 # toffSg 0-63, clear all
	${TRACE_BIN}/trace_cntl lvlmskg 0xfff 0x1ff 0  # <memory> <slow> <trigger>, tonSg 0-8 (debug is 8 := TLVL_{FATAL,ALERT,CRIT,ERROR,WARNING,NOTICE,INFO,LOG,DEBUG})
	${TRACE_BIN}/trace_cntl mode 3   # ton*
	
	if [ "$OTS_DEBUG_MODE" == "1" ]; then 
		# tonSg DEBUG+7 #to enable targeted bitmask
		
		tonSg 0-63 #enable all slow

		#enable kernel trace to memory buffer:
		#+test -f /proc/trace/buffer && { export TRACE_FILE=/proc/trace/buffer; tlvls | grep 'KERNEL 0xffffffff00ffffff' >/dev/null || { tonMg 0-63; toffM 24-31 -nKERNEL; }; }
		
		#tlvls #to see what is enabled by name
		#tonS -N DTC* 0-63 #to enable by name
		#tshow | grep DTC #to see memory printouts by name
		
		#end Trace helpful info
		#============================
	fi

	# Disable some very verbose trace outputs (e.g. from artdaq_database)
#	toffS 0-63 -n CONF:OpBase_C
#	toffS 0-63 -n CONF:OpLdStr_C
#	toffS 0-63 -n CONF:CrtCfD_C
#	toffS 0-63 -n COFS:DpFle_C
#	toffS 0-63 -n PRVDR:FileDB_C
#	toffS 0-63 -n PRVDR:FileDBIX_C
#	toffS 0-63 -n JSNU:Document_C
#	toffS 0-63 -n JSNU:DocUtils_C
#	toffS 0-63 -n CONF:LdStrD_C
#	toffS 0-63 -n FileDB:RDWRT_C

	TRACE_NAMLVLSET="\
CONF:LdStrD_C    0x1ff 0 0
FileDB:RDWRT_C   0x1ff 0 0
CONF:CrtCfD_C    0x1ff 0 0
COFS:DpFle_C     0x1ff 0 0
PRVDR:FileDBIX_C 0x1ff 0 0
JSNU:DocUtils_C  0x1ff 0 0
JSNU:Document_C  0x1ff 0 0
CONF:OpLdStr_C   0x1ff 0 0
PRVDR:FileDB_C   0x1ff 0 0
CONF:OpBase_C    0x1ff 0 0
JSONDocument.cpp 0x1ff 0 0
json_writer.cpp  0x1ff 0 0
json_reader.cpp  0x1ff 0 0
provider_filedb_readwrite.cpp 0x1ff 0 0
provider_filedb_index.cpp 0x1ff 0 0
provider_filedb.cpp 0x1ff 0 0
dispatch_filedb.cpp 0x1ff 0 0
detail_manageconfigs.cpp 0x1ff 0 0
detail_managedocument.cpp 0x1ff 0 0
filesystem_functions.cpp 0x1ff 0 0
options_operation_base.cpp 0x1ff 0 0
JSONDocument_utils.cpp  0x1ff 0 0
options_operation_managedocument.cpp  0x1ff 0 0
" ${TRACE_BIN}/trace_cntl namlvlset
	
	
	
fi



#############################
# Initializing StartOTS action file

#attempt to mkdir for full path so that it exists to move the database to
# assuming mkdir is non-destructive
#Note: quit file added to universally quit StartOTS scripts originating from same USER_DATA
#Note: local path quit file added to universally quit StartOTS scripts originating from same directory (regardless of USER_DATA)
# can not come from action file because individual StartOTS scripts need to respond to that one.
# The gateway supervisor StartOTS script drives the quit file.

OTSDAQ_STARTOTS_ACTION_FILE="${USER_DATA}/ServiceData/StartOTS_action_${THIS_HOST}.cmd" #the targeted hostname action script gives commands to StartOTS scripts running on that host
OTSDAQ_STARTOTS_QUIT_FILE="${USER_DATA}/ServiceData/StartOTS_action_quit.cmd" #the global quit gives exit commonds to the non-gateway StartOTS scripts
OTSDAQ_STARTOTS_LOCAL_QUIT_FILE=".StartOTS_action_quit.cmd" #the local quit is used to remove other StartOTS calls from the same directory (it catches the case when switching USER_DATA paths)

#if [ $ISREMOTE == 0 ]; then
	#out "ots script path     = ${SCRIPT_DIR}/ots         "
	#out "ots action path     = ${OTSDAQ_STARTOTS_ACTION_FILE}    "
	#out "ots quit path       = ${OTSDAQ_STARTOTS_QUIT_FILE}      "
	#out "ots local quit path = ${OTSDAQ_STARTOTS_LOCAL_QUIT_FILE}"
#fi
 
SAP_ARR=$(echo "${USER_DATA}/ServiceData" | tr '/' "\n")
SAP_PATH=""
for SAP_EL in ${SAP_ARR[@]}
do
	#echo $SAP_EL
	SAP_PATH="$SAP_PATH/$SAP_EL"
	#out "$SAP_PATH"
			
	mkdir -p $SAP_PATH &>/dev/null #hide output
done



#done initializing StartOTS action file
#############################

#############################

function killproc
{
	pid=$1
	
	if [ $ISREMOTE == 0 ]; then
		out "${Red}${Rev}Killing process ID ${pid}${RstClr}"
	fi
	
	count=10
	kill -9 ${pid} >/dev/null 2>&1  #gentler abort sig seems to cause core dumps
	# kill -0 ${pid} >/dev/null 2>&1
	while [ $? -eq 0 ]; do
		kill ${pid} >/dev/null 2>&1
		sleep 1
		count=$(( $count - 1 ))
		if [ $count -le 0 ]; then
			kill -9 ${pid} >/dev/null 2>&1
		fi
		
		kill -0 ${pid} >/dev/null 2>&1
	done
}
export -f killproc

#############################
# function to kill all things ots
function killprocs 
{	
	
	if [ $ISREMOTE == 0 ]; then
		out "Killing processes $1..."
	fi
	
	if [[ "x$1" == "x" ]]; then #kill all ots processes that share $USER_DATA

		pids=`ps aux|grep [o]ts.exe|grep ${USER_DATA}|awk '{print $2}'`
		for pid in $pids;do
			killproc $pid &
		done
		pids=`ps aux|grep [x]daq.exe|grep ${USER_DATA}|awk '{print $2}'`
		for pid in $pids;do
			killproc $pid &
		done
		pids=`ps aux|grep [o]tsConsoleFwd|grep ${USER_DATA}|awk '{print $2}'`
		for pid in $pids;do
			killproc $pid &
		done
		pids=`ps aux|grep [m]f_rcv_n_fwd|grep ${USER_DATA}|awk '{print $2}'`
		for pid in $pids;do
			killproc $pid &
		done		
	

		# for now (Aug-2023), stop killing artdaq and trust artdaq cleanup (this will also allowed share user accounts)
		# usershort=`echo $USER|cut -c 1-10`
		# for key in `ipcs|grep $usershort|grep ' 0 '|awk '{print $1}'`;do ipcrm -M $key;done
		
		sleep 1 #give time for cleanup to occur
		

	else #then killing only non-gateway contexts

		for contextPID in "${ContextPIDArray[@]}"
		do
			
			if [ $ISREMOTE == 0 ]; then
				out "${Red}${Rev}Killing Non-gateway process ID ${contextPID}${RstClr}"
			else
				out "${Red}${Rev}Killing Non-gateway process ID ${contextPID}${RstClr}"
			fi

			
			killproc ${contextPID} &

		done	

		unset ContextPIDArray #done with array of PIDs, so clear
		
		if [[ $1 == "ownedProcesses" && -v GATEWAY_PID ]]; then #in this case if variable is set, kill gateway too
			out "${Red}${Rev}Killing Gateway process ID ${GATEWAY_PID}${RstClr}"
			killproc ${GATEWAY_PID} &
			unset GATEWAY_PID 
		fi

		sleep 1 #give time for cleanup to occur
	fi		
	
	#kill lingering artdaq processes by partition number
	pids=`ps aux|grep "partition_number: ${ARTDAQ_PARTITION}"|awk '{print $2}'`
	for pid in $pids;do
		killproc $pid &
	done
	pids=`ps aux|grep "partition_${ARTDAQ_PARTITION}"|awk '{print $2}'`
	for pid in $pids;do
		killproc $pid &
	done
	pids=`ps aux|grep "art -c ${USER_DATA}"|awk '{print $2}'`
	for pid in $pids;do
		killproc $pid &
	done

	# for now (Aug-2023), stop killing artdaq and trust artdaq cleanup (this will also allowed share user accounts)
	# #now hard kill any processes that may be stuck and detached:
	# killall -9 art &>/dev/null 2>&1 #hide output
	# killall -9 boardreader &>/dev/null 2>&1 #hide output
	# killall -9 eventbuilder &>/dev/null 2>&1 #hide output
	# killall -9 datalogger &>/dev/null 2>&1 #hide output
	# killall -9 dispatcher &>/dev/null 2>&1 #hide output
	# killall -9 routing_manager &>/dev/null 2>&1 #hide output
	# ipcrm -a &>/dev/null 2>&1 #hide output #clean-up shared memory
	
	# if [[ "x$1" == "x" ]]; then #kill all ots processes, not in background or it kills the new launch sometimes!
	# 	killall -9 xdaq.exe  >/dev/null 2>&1 #hide output
	# 	killall -9 otsConsoleFwd  >/dev/null 2>&1 #hide output
	# fi
   
	if [ $ISREMOTE == 0 ]; then
		out "Done killing processes $1 ${RstClr}"
	fi
	
} #end killprocs
export -f killprocs


if [[ $KILLALL != 0 ]]; then

	out "${Yellow}${Bold}${REV}******************************************************${RstClr}"
	out "${Yellow}${Bold}${REV}*************       kill otsdaq!        **************${RstClr}"
    out "${Yellow}${Bold}${REV}******************************************************${RstClr}"
	
	#try to force kill other StartOTS scripts
	echo "KILL_ALL" > $OTSDAQ_STARTOTS_QUIT_FILE
	echo "KILL_ALL ${THIS_HOST}" > $OTSDAQ_STARTOTS_LOCAL_QUIT_FILE
	
    echo  -e "${IBRed}"

	killall -9 art &>/dev/null 2>&1 #hide output
	killall -9 boardreader &>/dev/null 2>&1 #hide output
	killall -9 eventbuilder &>/dev/null 2>&1 #hide output
	killall -9 datalogger &>/dev/null 2>&1 #hide output
	killall -9 dispatcher &>/dev/null 2>&1 #hide output
	killall -9 routing_manager &>/dev/null 2>&1 #hide output
	ipcrm -a &>/dev/null 2>&1 #hide output #clean-up shared memory
    #killprocs	
	
    out "Done with ots kill-all." 
	
	#kills self too:
	killall -9 xdaq.exe  &>/dev/null 2>&1 #hide output
	killall -9 otsConsoleFwd  &>/dev/null 2>&1 #hide output
	killall -9 ots &>/dev/null 2>&1 #hide output
	
	exit
fi

#KEEP for debugging of defaults
#echo "ISMACROMAKER $ISMACROMAKER"
#echo "ISCONFIG $ISCONFIG"
#echo "QUIET $QUIET"
#echo "CHROME $CHROME"
#echo "FIREFOX $FIREFOX"
#echo "BACKUPLOGS $BACKUPLOGS"
#echo "RELAUNCHCHECK $RELAUNCHCHECK"


# Old host resolution approach:
#SERVER=`hostname -f || ifconfig eth0|grep "inet addr"|cut -d":" -f2|awk '{print $1}'`
export SUPERVISOR_SERVER=$THIS_HOST #$SERVER
if [ $ISCONFIG == 1 ]; then
    export OTS_CONFIGURATION_WIZARD_SUPERVISOR_SERVER=$SUPERVISOR_SERVER
fi

#At one point, could be File, Database, DatabaseTest
#  Now,.. artdaq_database expects File, and the ARTDAQ_DATABASE_URI decides the rest
export CONFIGURATION_TYPE=File

# Setup extra environment pointers when building with MRB
if [ "x$MRB_BUILDDIR" != "x" ] && [ -e $OTSDAQ_DEMO_DIR/CMakeLists.txt ]; then
    export OTSDAQDEMO_BUILD=${MRB_BUILDDIR}/otsdaq_demo
    export OTSDAQ_DEMO_LIB=`echo ${MRB_BUILDDIR}/otsdaq_demo/slf7*/lib`
    export OTSDAQDEMO_REPO=$OTSDAQ_DEMO_DIR
    unset  OTSDAQ_DEMO_DIR
fi

if [ "x$MRB_BUILDDIR" != "x" ] && [ -e $OTSDAQ_DIR/CMakeLists.txt ]; then
    export OTSDAQ_BUILD=${MRB_BUILDDIR}/otsdaq
    export OTSDAQ_LIB=`echo ${MRB_BUILDDIR}/otsdaq/slf7*/lib`
    export OTSDAQ_REPO=$OTSDAQ_DIR
    export FHICL_FILE_PATH=.:$OTSDAQ_REPO/tools/fcl:$FHICL_FILE_PATH
fi
  
if [ "x$MRB_BUILDDIR" != "x" ] && [ -e $OTSDAQ_UTILITIES_DIR/CMakeLists.txt ]; then
    export OTSDAQUTILITIES_BUILD=${MRB_BUILDDIR}/otsdaq_utilities
    export OTSDAQ_UTILITIES_LIB=`echo ${MRB_BUILDDIR}/otsdaq_utilities/slf7*/lib`
    export OTSDAQUTILITIES_REPO=$OTSDAQ_UTILITIES_DIR
fi

if [ "x$OTSDAQ_DEMO_DIR" == "x" ]; then
    export OTSDAQ_DEMO_DIR=$OTSDAQDEMO_BUILD
fi

if [ "x$USER_WEB_PATH" == "x" ]; then  #setup the location for user web-apps
    export USER_WEB_PATH=$OTSDAQ_DEMO_DIR/UserWebGUI 
fi

#setup web path as XDAQ is setup.. 
#then make a link to user specified web path.
WEB_PATH=${OTSDAQ_UTILITIES_DIR}/WebGUI

# TODO: Maybe bring these back if user starts in verbose (quiet=0)
#out "WEB_PATH=$WEB_PATH"
#out "USER_WEB_PATH=$USER_WEB_PATH"
#out "Making symbolic link to USER_WEB_PATH"
#out "ln -s $USER_WEB_PATH $WEB_PATH/UserWebPath"

rm $WEB_PATH/UserWebPath &>/dev/null  #delete link first, hide output
ln -s $USER_WEB_PATH $WEB_PATH/UserWebPath &>/dev/null  #make link, hide output


if [ "x$USER_DATA" == "x" ]; then

    out "${Red}${Bold}${Blink}Fatal Error${RstClr}."
    out "Environment variable ${Cyan}${Bold}USER_DATAr${RstClr} has not been setup!"
    out "To setup, use 'export USER_DATA=<path to user data>'"

    out "(If you do not have a user data folder copy '<path to ots source>/otsdaq-demo/Data' as your starting point.)"
    out "${Red}${Bold}${Blink}Aborting launch${RstClr} "

    
    exit    
fi

if [ ! -d $USER_DATA ]; then

    out "${Red}${Bold}${Blink}Fatal Error${RstClr}."
    out "USER_DATA=$USER_DATA"
    out "Environment variable ${Cyan}${Bold}USER_DATA${RstClr} does not point to a valid directory!"
    out "To setup, use 'export USER_DATA=<path to user data>'"


    out "(If you do not have a user data folder copy '<path to ots source>/otsdaq-demo/Data' as your starting point.)"
    out "${Red}${Bold}${Blink}Aborting launch${RstClr} "

    
    exit   
fi

#check for new Slow Controls context table
if [ ! -e ${USER_DATA}/TableInfo/SlowControlsDashboardSupervisorTableInfo.xml ]; then
	#if missing, attempt to copy
	cp ${MRB_SOURCE}/otsdaq/data-core/TableInfo/ContextGroup/SlowControlsDashboardSupervisorTableInfo.xml ${USER_DATA}/TableInfo/
fi

#print out important environment variables
if [ $ISREMOTE == 0 ]; then
	info "\$USER_DATA               = ${YELLOW}${USER_DATA}${RstClr}          "
	info "\$ARTDAQ_DATABASE_URI     = ${YELLOW}${Bold}${ARTDAQ_DATABASE_URI}${DBold}${RstClr}"
	info "\$OTSDAQ_DATA             = ${YELLOW}${OTSDAQ_DATA}${RstClr}        "
fi
#end print out important environment variables

#check for antiquated artdaq database
ARTDAQ_DATABASE_TYPE=$(echo ${ARTDAQ_DATABASE_URI}|sed 's|:.*||')

#out "Database type = $ARTDAQ_DATABASE_TYPE"

#if not using filesystem point to a db "services" folder
if [ $ARTDAQ_DATABASE_TYPE == "filesystemdb" ]; then


	#basic philosophy:
	#	use this section to up data user data and databases
	#	after update, save a file
	#	check for that file's existence before doing update procedure

	ARTDAQ_DATABASE_FILESYSTEM_PATH=`echo ${ARTDAQ_DATABASE_URI}|sed 's|.*//|/|'`

	if [ ! -e ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromIndexRebuild ]; then
	    # Rebuild ARTDAQ_DATABASE indicies
	    out "Rebuilding database indices..."
	    rebuild_database_index >/dev/null 2>&1; rebuild_database_index --uri=${ARTDAQ_DATABASE_URI} >/dev/null 2>&1
	    
	    mv ${ARTDAQ_DATABASE_FILESYSTEM_PATH} ${ARTDAQ_DATABASE_FILESYSTEM_PATH}.bak.$$		
	    mv ${ARTDAQ_DATABASE_FILESYSTEM_PATH}_new ${ARTDAQ_DATABASE_FILESYSTEM_PATH}
	    echo "rebuilt" > ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromIndexRebuild
	   	out "Database indices rebuilt. Marked complete at ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromIndexRebuild"
	fi

	if [ ! -e ${USER_DATA}/ServiceData/.updateDB_nov9_2019a.cmd ]; then	
		out "Updating DB to comply with November 2019 changes..."		
		otsdaq_beautify_artdaq_tables		
		echo "done" > ${USER_DATA}/ServiceData/.updateDB_nov9_2019a.cmd	
	fi

	#check for somewhat-antiquated(pre-configuration-to-table) artdaq database
	if [ ! -e ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromConfigurationToTableConversion2 ]; then
	    out "Converting configuration to table for user data and databases..."
	    
	    #backup because we are scared
	    cp -r ${ARTDAQ_DATABASE_FILESYSTEM_PATH} ${ARTDAQ_DATABASE_FILESYSTEM_PATH}bk12345
	    cp -r ${USER_DATA} ${USER_DATA}bk12345
	    
	    otsdaq_convert_config_to_table	
	    echo "converted" > ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromConfigurationToTableConversion2
	    out "Conversion complete. You must run wiz mode once now to activate the configuration changes. Marked complete at ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromConfigurationToTableConversion2"
	    
	    if [ $ISCONFIG == 0 ]; then		
			exit
	    fi
	fi
	if [ -d ${USER_DATA}/ConfigurationInfo ]; then
	    out "Converting configuration to table for user data and databases..."
	    
	    #backup because we are scared
	    cp -r ${ARTDAQ_DATABASE_FILESYSTEM_PATH} ${ARTDAQ_DATABASE_FILESYSTEM_PATH}bk12345
	    cp -r ${USER_DATA} ${USER_DATA}bk12345
	    
	    otsdaq_convert_config_to_table
	    echo "converted" > ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/fromConfigurationToTableConversion
	    out "Conversion complete. You must run wiz mode once now to activate the configuration changes."
	    
	    if [ $ISCONFIG == 0 ]; then		
			exit
	    fi
	fi
else
	ARTDAQ_DATABASE_FILESYSTEM_PATH=${USER_DATA}/ServiceData/artdaq_database_services
	mkdir $ARTDAQ_DATABASE_FILESYSTEM_PATH &>/dev/null 2>&1 #hide output
fi	
		
#check for somewhat-antiquated artdaq 'DAQ' tables and auto-fix
if [ ! -e ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/artdaqDaqTableConversion ]; then
    out "Converting artdaq 'daq' tables in databases..."
    
    #backup because we are scared
    cp -r ${ARTDAQ_DATABASE_FILESYSTEM_PATH} ${ARTDAQ_DATABASE_FILESYSTEM_PATH}bk12346
    cp -r ${USER_DATA} ${USER_DATA}bk12346
    
    otsdaq_convert_artdaq_daq_tables
    echo "converted" > ${ARTDAQ_DATABASE_FILESYSTEM_PATH}/artdaqDaqTableConversion
    out "Conversion complete. You must run wiz mode once now to activate the configuration changes."
    
    if [ $ISCONFIG == 0 ]; then		
		exit
    fi
fi

export TABLE_INFO_PATH=${USER_DATA}/TableInfo
export SERVICE_DATA_PATH=${USER_DATA}/ServiceData
export XDAQ_CONFIGURATION_DATA_PATH=${USER_DATA}/XDAQConfigurations
export LOGIN_DATA_PATH=${USER_DATA}/ServiceData/LoginData
export LOGBOOK_DATA_PATH=${USER_DATA}/ServiceData/LogbookData
export PROGRESS_BAR_DATA_PATH=${USER_DATA}/ServiceData/ProgressBarData
export ROOT_DISPLAY_CONFIG_PATH=${USER_DATA}/RootDisplayConfigData

if [ "x$OTSDAQ_DATA" == "x" ];then
    export OTSDAQ_DATA=/tmp
fi

# Make directories if they do not exist
out "Checking directories..."

if [ "x$ROOT_BROWSER_PATH" == "x" ];then
    export ROOT_BROWSER_PATH=${OTSDAQ_DATA}
fi

if [ "x$OTSDAQ_LOG_DIR" == "x" ];then
    export OTSDAQ_LOG_DIR="${USER_DATA}/Logs"
fi

if [ "x${ARTDAQ_OUTPUT_DIR}" == "x" ]; then
    export ARTDAQ_OUTPUT_DIR="${USER_DATA}/ArtdaqData"
fi

if [ ! -d $OTSDAQ_DATA ]; then
	if [ ! -L $OTSDAQ_DATA ]; then
		mkdir -p $OTSDAQ_DATA || die "Error: OTSDAQ_DATA path (${OTSDAQ_DATA}) does not exist and mkdir failed!" 
	else
		mkdir -p `readlink -f $OTSDAQ_DATA`  || die "Error: OTSDAQ_DATA path (${OTSDAQ_DATA}) does not exist and mkdir failed!" 
	fi
fi

if [ ! -d $ARTDAQ_OUTPUT_DIR ]; then
	if [ ! -L $ARTDAQ_OUTPUT_DIR ]; then
		mkdir -p $ARTDAQ_OUTPUT_DIR || die "Error: ARTDAQ_OUTPUT_DIR path (${ARTDAQ_OUTPUT_DIR}) does not exist and mkdir failed!" 
	else
		mkdir -p `readlink -f $ARTDAQ_OUTPUT_DIR`  || die "Error: ARTDAQ_OUTPUT_DIR path (${ARTDAQ_OUTPUT_DIR}) does not exist and mkdir failed!" 
	fi
fi

if [ ! -d $OTSDAQ_LOG_DIR ]; then
	if [ ! -L $OTSDAQ_LOG_DIR ]; then
		mkdir -p $OTSDAQ_LOG_DIR  || die "Error: OTSDAQ_LOG_DIR path (${OTSDAQ_LOG_DIR}) does not exist and mkdir failed!" 
	else
		mkdir -p `readlink -f $OTSDAQ_LOG_DIR`  || die "Error: OTSDAQ_LOG_DIR path (${OTSDAQ_LOG_DIR}) does not exist and mkdir failed!" 
	fi
fi

export OTSDAQ_LOG_ROOT=$OTSDAQ_LOG_DIR

if [ ! -d ${USER_DATA}/MessageFacilityConfigurations ];then
	if [ ! -L ${USER_DATA}/MessageFacilityConfigurations ]; then
		mkdir -p ${USER_DATA}/MessageFacilityConfigurations || die "Error: USER_DATA/MessageFacilityConfiguration path (${USER_DATA}/MessageFacilityConfiguration) does not exist and mkdir failed!" 
	else
		mkdir -p `readlink -f ${USER_DATA}/MessageFacilityConfigurations` die "Error: USER_DATA/MessageFacilityConfiguration path (${USER_DATA}/MessageFacilityConfiguration) does not exist and mkdir failed!" 
	fi
fi


#out "ARTDAQ_MFEXTENSIONS_DIR=" ${ARTDAQ_MFEXTENSIONS_DIR}

#at end print out connection instructions using MAIN_URL
MAIN_URL="unknown_url"
MPI_RUN_CMD=""

#declare launch functions


####################################################################
####################################################################
################## MacroMaker Mode OTS Launch ######################
####################################################################
####################################################################
launchOTSMacromaker() {	
	
	#kill all things otsdaq, before launching new things	
	killprocs
	
	#cleanup alive files
	rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive* &>/dev/null 2>&1 #hide output #remove alive file


	out #blank line
	out "${Blue}${REV}                                                       ${RstClr}"
	out "${Blue}${REV} ***************************************************** ${RstClr}"
	out "${Blue}${REV} *******  Launching ots in MacroMaker MODE!  ********* ${RstClr}"	
	out "${Blue}${REV} ***************************************************** ${RstClr}"
	out "${Blue}${REV}                                                       ${RstClr}"
	out #blank line
		
	
	export MACROMAKER_MODE=1
	#parameters are shifted during initial parsing, so the filename input should always be at $1
	# out "\$1 = ${1}"
	
	if [[ "x$1" = "x" ]]; then
		out "Error! Must specify fcl file path parameter for Macro Maker mode!${RstClr}"

		out "Example Macro Maker mode usage:"
		out "\tots -mm srcs/otsdaq/tools/fcl/MacroMakerModeExample.fcl"
		out "\tots -mm \$USER_DATA/MacroMakerModeConfigurations/MacroMakerModeFhiclDump.fcl"

		out "To get started, copy the example FHiCL configuration file here: ${OTSDAQ_DIR}/tools/fcl/MacroMakerModeExample.fcl"
		oout #blank lineut
		out "Note: your last configure transition FE state is saved to \$USER_DATA/MacroMakerModeConfigurations/MacroMakerModeFhiclDump.fcl"
		exit
	fi

	if [[ "$1" = /* ]]; then #absolute path
		export CONFIGURATION_INIT_FCL=$1
	else
		export CONFIGURATION_INIT_FCL="${PWD}/$1"
	fi
	
	out "CONFIGURATION_INIT_FCL = ${CONFIGURATION_INIT_FCL}"
	
	#setup wiz mode environment variables
	export FE_SUPERVISOR_ID=280
	export MACROMAKER_SUPERVISOR_ID=290
	MAIN_PORT=2015

	if [ "x$OTS_MAIN_PORT" != "x" ]; then
	  MAIN_PORT=${OTS_MAIN_PORT}
	fi
	export PORT=${MAIN_PORT} #must be exported for xml env var conversion	
	
	
	#check for mm xml file, if missing download it	
	#FIXME after move to github
	# if [ ! -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake.xml ]; then
	# 	out "Downloading MacroMaker mode context configuration..."
	# 	wget https://cdcvs.fnal.gov/redmine/projects/otsdaq/repository/revisions/develop/raw/data-core/XDAQConfigurations/otsConfiguration_MacroMaker_CMake.xml -P ${XDAQ_CONFIGURATION_DATA_PATH} --no-check-certificate	
	# fi
	
	# #check for message facility file, if missing download it	
	# if [ ! -e ${USER_DATA}/MessageFacilityConfigurations/MessageFacilityWithCout.fcl ]; then
	# 	out "Downloading MacroMaker mode context configuration..."
	# 	wget https://cdcvs.fnal.gov/redmine/projects/otsdaq/repository/revisions/develop/raw/data-core/MessageFacilityConfigurations/MessageFacilityWithCout.fcl -P ${USER_DATA}/MessageFacilityConfigurations --no-check-certificate	
	# fi
	
		
	#substitute environment variables into template wiz-mode xdaq config xml
	envsubst <${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake.xml > ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml
	
	#use safe Message Facility fcl in wiz mode
	export OTSDAQ_LOG_FHICL=${USER_DATA}/MessageFacilityConfigurations/MessageFacilityWithCout.fcl
	

	out "Starting MacroMaker mode on PORT ${PORT}; to change, please setup environment variable OTS_MAIN_PORT."
	out "MacroMaker mode ots context is defined by ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml"
	

	#attempt to avoid false starts by xdaq by detecting constructor, and relaunching
	rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat >/dev/null 2>&1 #hide output #remove alive file
	OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
	# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
	if [ "$OTS_CONTEXT_UP" != "bad" ]; then
		#sometimes the PORT takes extra time to close
		out "Retrying... MacroMaker mode context http PORT is already in use! http://${THIS_HOST}:${PORT}"
		sleep 4
		OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
		# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
		if [ "$OTS_CONTEXT_UP" != "bad" ]; then
			die "MacroMaker mode context http PORT is already in use! http://${THIS_HOST}:${PORT}"
		fi
	fi
		
	if [ $QUIET == 1 ]; then

		if [ $BACKUPLOGS == 1 ]; then
			DATESTRING=`date +'%s'`
			out "     Backing up logfile to *** ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.${DATESTRING}.txt ***"
			mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.${DATESTRING}.txt
		fi		

		out #blank line
		out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}MacroMaker Mode${RstClr}' output into ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt ***  "
		out #blank line

		# echo "${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt &"
		${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt &
	else
		${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml &
	fi
	LAST_OTS_PID=$!
	
	if [ $RELAUNCHCHECK == 1 ]; then
	
		#test for relaunch
		# 4 times quietly, then get louder
		
		sleep 2
		OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
		#out "OTS_IS_ALIVE=${OTS_IS_ALIVE}"

		for t in {1..4}; do
			if [ "x$OTS_IS_ALIVE" == "x" ]; then		
				sleep 2
				OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
				out "Checking http://${THIS_HOST}:${PORT}..."
			else # found the supervisor!
				# have seen instances where http peer transport xdaq PORT is not established, but xdaq context still is constructed
				# so clear alive, if ots script can not connect to PORT
				OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
				# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
				if [ "$OTS_CONTEXT_UP" == "bad" ]; then
					out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
					OTS_IS_ALIVE=
				fi
				break
			fi
		done
		unset i

		# # Loop 4 times waiting for it to come up
		# for t in {1..4}; do
		# 	if [ "x$OTS_IS_ALIVE" == "x" ]; then		
		# 		sleep 1
		# 		OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
		# 	else
		# 		break
		# 	fi
		# done
		
		# Alert user to the problem and keep trying
		while [ "x$OTS_IS_ALIVE" == "x" ]; do
			warning "Could not verify successful ots Macro Maker mode context launch, relaunching ots Macro Maker mode context..."									
			killproc ${LAST_OTS_PID} 	
			sleep 2
			
			if [ $QUIET == 1 ]; then
				out #blank line
				out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}MacroMaker Mode${RstClr}' output into ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt ***  "
				out #blank line
				echo -e "\n\nAttempting restart\n\n" >> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt
				${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml &>> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mm-${THIS_HOST}.txt &
			else
				${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_MacroMaker_CMake_Run.xml &
			fi
			LAST_OTS_PID=$!
			
			# #verify relaunch
			# sleep 8 #give time before relaunch test
			# OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat)"

			#verify relaunch
			sleep 2
			OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat)"
			# Test for start 16 times with short sleep
			for t in {1..16}; do
				if [ "x$OTS_IS_ALIVE" == "x" ]; then		
					sleep 2
					OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
					out "Checking http://${THIS_HOST}:${PORT}..."
				else  # found the supervisor!
					OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
					# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
					if [ "$OTS_CONTEXT_UP" == "bad" ]; then
						out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
						OTS_IS_ALIVE=
					fi
					break
				fi
			done
			
		done
		
		info "Verified successful ots Macro Maker mode context ${THIS_HOST}-${PORT} launch..."
	fi
	
	MAIN_URL="http://${THIS_HOST}:${PORT}/urn:xdaq-application:lid=$MACROMAKER_SUPERVISOR_ID/Verify?code=$(cat ${SERVICE_DATA_PATH}//OtsWizardData/sequence.out)"
	
	out "\tots Macro Maker access code = $(cat ${SERVICE_DATA_PATH}//OtsWizardData/sequence.out)"
	
	printMainURL &
	
	
} #end launchOTSMacromaker
export -f launchOTSMacromaker

####################################################################
####################################################################
################## Wiz Mode OTS Launch ###########################
####################################################################
####################################################################
launchOTSWiz() {	
	
	#kill all things otsdaq, before launching new things	
	killprocs
	
	#cleanup alive files
	rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive* &>/dev/null 2>&1 #hide output #remove alive file



	out #blank line
	out "${Red}${REV}                                                       ${RstClr}"
	out "${Red}${REV} ***************************************************** ${RstClr}"
	out "${Red}${REV} ***********  Launching ots in WIZ MODE!  ************ ${RstClr}"	
	out "${Red}${REV} ***************************************************** ${RstClr}"
	out "${Red}${REV}                                                       ${RstClr}"
	out #blank line
		
	#setup wiz mode environment variables
	export CODE_EDITOR_SUPERVISOR_ID=240
	export CONSOLE_SUPERVISOR_ID=260
	export CONFIGURATION_GUI_SUPERVISOR_ID=280
	export WIZARD_SUPERVISOR_ID=290	
	export OTS_CONFIGURATION_WIZARD_SUPERVISOR_ID=290	
	MAIN_PORT=2015

   
	if [ "x$OTS_WIZ_MODE_MAIN_PORT" != "x" ]; then
	  MAIN_PORT=${OTS_WIZ_MODE_MAIN_PORT}
	elif [ "x$OTS_MAIN_PORT" != "x" ]; then
	  MAIN_PORT=${OTS_MAIN_PORT}
	fi
	export PORT=${MAIN_PORT} #must be exported for xml env var conversion
	
	
	
	####################################################################
	########### start console & message facility handling ##############
	####################################################################
	#decide which MessageFacility console viewer to run
	# and configure otsdaq MF library with MessageFacility*.fcl to use

	#use safe Message Facility fcl in wiz mode
	
	#modify the PORT to avoid wiz mode conflicts
	cp ${USER_DATA}/MessageFacilityConfigurations/MessageFacility.fcl ${USER_DATA}/MessageFacilityConfigurations/MessageFacilityWiz.fcl 
	PORTMFOFF=$((30000 + $PORT))
	sed -i s/30000/${PORTMFOFF}/g ${USER_DATA}/MessageFacilityConfigurations/MessageFacilityWiz.fcl 
	
	#this fcl tells the MF library used by ots source how to behave
	export OTSDAQ_LOG_FHICL=${USER_DATA}/MessageFacilityConfigurations/MessageFacilityWiz.fcl 
	#out "OTSDAQ_LOG_FHICL=" ${OTSDAQ_LOG_FHICL}
	
	#defeault to web viewer
	USE_WEB_VIEWER=1
	USE_QT_VIEWER=0
	
	if [[ $USE_WEB_VIEWER == "1" ]]; then
		#out "CONSOLE: Using web console viewer"
		
		#start quiet forwarder with wiz receiving PORT and destination PORT parameter file
		cp ${USER_DATA}/MessageFacilityConfigurations/QuietForwarderWiz.cfg ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg
		
		#modify the PORT to avoid wiz mode conflicts
		PORTMFOFF1=$((30001 + $PORT)) #make PORT + 1
		sed -i s/30001/${PORTMFOFF1}/g ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg
		sed -i s/30000/${PORTMFOFF}/g ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg
		
		#RAR nov 2019 -- always send forwarder to file (with new trace, verbose mode is handled by trace, no need to printout twice)
		#if [ $QUIET == 1 ]; then

			if [ $BACKUPLOGS == 1 ]; then
				DATESTRING=`date +'%s'`
				out "     Backing up logfile to ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.${DATESTRING}.txt${RstClr}"
				mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.${DATESTRING}.txt
			fi
			
			#out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Message Facility${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt${RstClr}"
			otsConsoleFwd ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg  &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt &
		#else
		#	otsConsoleFwd ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg  &
		#fi		 	 	

	fi
	
	if [[ $USE_QT_VIEWER == "1" ]]; then
		out "CONSOLE: Using QT console viewer"
		if [ "x$ARTDAQ_MFEXTENSIONS_DIR" == "x" ]; then #qtviewer library missing!

			out "Error: ARTDAQ_MFEXTENSIONS_DIR missing for qtviewer!"


			exit
		fi
		
		#start the QT Viewer (only if it is not already started)
		if [ $( ps aux|egrep -c $USER.*msgviewer ) -eq 1 ]; then				
			msgviewer -c ${USER_DATA}/MessageFacilityConfigurations/QTMessageViewerGen.fcl  &
			sleep 2	 #give time for msgviewer to be ready for messages	
		fi		
	fi
	
	####################################################################
	########### end console & message facility handling ################
	####################################################################
	
	
	
	
		
	#substitute environment variables into template wiz-mode xdaq config xml
	envsubst <${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake.xml > ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml
	
	

	out "Starting wiz mode on PORT ${PORT}; to change, please setup environment variable OTS_WIZ_MODE_MAIN_PORT."
	out "Wiz mode ots context is defined by ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml"

	#attempt to avoid false starts by xdaq by detecting constructor, and relaunching
	rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat >/dev/null 2>&1 #hide output #remove alive file
	OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
	# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
	if [ "$OTS_CONTEXT_UP" != "bad" ]; then
		#sometimes the PORT takes extra time to close
		out "Retrying... Wiz context http PORT is already in use! http://${THIS_HOST}:${PORT}"
		sleep 4
		OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
		# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
		if [ "$OTS_CONTEXT_UP" != "bad" ]; then
			die "Wiz context http PORT is already in use! http://${THIS_HOST}:${PORT}"
		fi
	fi
		
	if [ $QUIET == 1 ]; then


		if [ $BACKUPLOGS == 1 ]; then
			DATESTRING=`date +'%s'`
			out "     Backing up logfile to *** ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.${DATESTRING}.txt ***"
			mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.${DATESTRING}.txt
		fi
		
		out #blank line
		out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Wiz Mode${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt${RstClr}"
		out #blank line

		${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt &
	else
		${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml &
	fi
	LAST_OTS_PID=$!

	if [ $RELAUNCHCHECK == 1 ]; then
		
		#test for relaunch
		# 4 times quietly, then get louder

		sleep 2
		OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
		
		for t in {1..4}; do
			if [ "x$OTS_IS_ALIVE" == "x" ]; then		
				sleep 2
				OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
				out "Checking http://${THIS_HOST}:${PORT}..."
			else # found the supervisor!
				# have seen instances where http peer transport xdaq PORT is not established, but xdaq context still is constructed
				# so clear alive, if ots script can not connect to PORT
				OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
				# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
				if [ "$OTS_CONTEXT_UP" == "bad" ]; then
					out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
					OTS_IS_ALIVE=
				fi
				break
			fi
		done
		unset i

		#out "OTS_IS_ALIVE=${OTS_IS_ALIVE}"
	
		while [ "x$OTS_IS_ALIVE" == "x" ]; do
			warning "Could not verify successful ots wiz context launch, relaunching ots wiz context..."			
			killproc ${LAST_OTS_PID} 
			sleep 2
			
			if [ $QUIET == 1 ]; then
				out #blank line
				out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Wiz Mode${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt${RstClr}"
				out #blank line
				echo -e "\n\nAttempting restart\n\n" >> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt
				${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml &>> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-wiz-${THIS_HOST}.txt &
			else
				${xdaqPrefix} xdaq.exe -p ${PORT} -h ${THIS_HOST} -e ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_Wizard_CMake_Run.xml &
			fi
			LAST_OTS_PID=$!
			
			#verify relaunch
			sleep 2
			OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat)"
			# Test for start 16 times with short sleep
			for t in {1..16}; do
				if [ "x$OTS_IS_ALIVE" == "x" ]; then		
					sleep 2
					OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-wiz-0.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
					out "Checking http://${THIS_HOST}:${PORT}..."
				else  # found the supervisor!
					OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
					# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
					if [ "$OTS_CONTEXT_UP" == "bad" ]; then
						out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
						OTS_IS_ALIVE=
					fi
					break
				fi
			done
	
		done
		
		info "Verified successful ots wiz context launch..."
	fi
	out #blank line
	
	################
	# start node db server
	
	#out "ARTDAQ_UTILITIES_DIR=" ${ARTDAQ_UTILITIES_DIR}
	#cd $ARTDAQ_UTILITIES_DIR/node.js
	#as root, once...
	# chmod +x setupNodeServer.sh 
	# ./setupNodeServer.sh 
	# chown -R products:products *
	
	#uncomment to use artdaq db nodejs web gui
	#node serverbase.js > /tmp/${USER}_serverbase.log &
	
	MAIN_URL="http://${THIS_HOST}:${PORT}/urn:xdaq-application:lid=$WIZARD_SUPERVISOR_ID/Verify?code=$(cat ${SERVICE_DATA_PATH}//OtsWizardData/sequence.out)"
	
	out #blank line
	out "\tots Wiz Mode access code = $(cat ${SERVICE_DATA_PATH}//OtsWizardData/sequence.out)"	
	out #blank line
	out "The length of the Wiz Mode access code can be changed (default is removed file, length of 4, and not random):\n\t\t\t\t\t\t\t\techo 8 > ${SERVICE_DATA_PATH}/OtsWizardData/sequence.dat"


	printMainURL &
	
} #end launchOTSWiz
export -f launchOTSWiz
		
####################################################################
####################################################################
################## Normal Mode OTS Launch ##########################
####################################################################
####################################################################

#make URL print out a function so that & syntax can be used to run in background (user has immediate terminal access)
#ContextPIDArray is context PID array 
launchOTS() {
	
	ISGATEWAYLAUNCH=1
	if [ "x$1" != "x" ]; then #if parameter, then is nongateway launch
		ISGATEWAYLAUNCH=0
		killprocs nongateway
		
		
		#if [ $BACKUPLOGS == 0 ]; then
			
			#could do something.. but do not delete all Logs!
			
			#cleanup log files
			#out "Cleaning LOG files at ${OTSDAQ_LOG_DIR} ${RstClr}"
			#rm -rf ${OTSDAQ_LOG_DIR}/* &>/dev/null 2>&1 #hide output #remove alive file
		#fi
		
		
	else 					#else is full gateway and nongateway launch
		unset GATEWAY_PID
		#kill all things otsdaq, before launching new things	
		killprocs

	fi

	#clear files initially
	echo "0" > $OTSDAQ_STARTOTS_ACTION_FILE
	echo "0" > $OTSDAQ_STARTOTS_QUIT_FILE
	echo "0" > $OTSDAQ_STARTOTS_LOCAL_QUIT_FILE


	##############################################################################
	XDAQ_OTS_XML="ots" 	#used for normal mode launch as copy location for stable script launching
	##############################################################################
	
	if [ $ISREMOTE == 0 ]; then

		out #blank line
		out "${Purple}${REV}                                                       ${RstClr}"
		out "${Purple}${REV} ***************************************************** ${RstClr}"
		if [ $ISGATEWAYLAUNCH == 1 ]; then
			out "${Purple}${REV} ***********       Launching ots!         ************ ${RstClr}"

			#copy once in GATEWAY launch so xdaq processes are not writing to file during bash startup
			cp ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_CONFIGURATION_XML}.xml ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml
		else
			out "${Purple}${REV} *******    Launching ots Non-gateway Apps!    ******* ${RstClr}"

			#copy once in NON-GATEWAY launch if file not already created (by GATEWAY launch copy)
			if [ ! -f ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml ]; then
				cp ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_CONFIGURATION_XML}.xml ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml
			fi
		fi
		out "${Purple}${REV} ***************************************************** ${RstClr}"
		out "${Purple}${REV}                                                       ${RstClr}"
		out #blank line
		out "XDAQ Configuration XML   = ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml"	
		
	fi
	
	####################################################################
	########### start console & message facility handling ##############
	####################################################################
	#decide which MessageFacility console viewer to run
	# and configure otsdaq MF library with MessageFacility*.fcl to use
	
	export OTSDAQ_LOG_FHICL=${USER_DATA}/MessageFacilityConfigurations/MessageFacilityGen.fcl
	#this fcl tells the MF library used by ots source how to behave
	#out "OTSDAQ_LOG_FHICL=" ${OTSDAQ_LOG_FHICL}
	
	
	if [[ $ISGATEWAYLAUNCH == 1 ]]; then

		USE_WEB_VIEWER="$(cat ${USER_DATA}/MessageFacilityConfigurations/UseWebConsole.bool 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
		USE_QT_VIEWER="$(cat ${USER_DATA}/MessageFacilityConfigurations/UseQTViewer.bool 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
		# out "USE_WEB_VIEWER =" ${USE_WEB_VIEWER}
		# out "USE_QT_VIEWER =" ${USE_QT_VIEWER}		
		
		if [[ $USE_WEB_VIEWER == "1" ]]; then

			if [ $ISREMOTE == 0 ]; then
				info "Launching message facility web console assistant...${RstClr}"
			fi
			
			#start quiet forwarder with receiving PORT and destination PORT parameter file
			cp ${USER_DATA}/MessageFacilityConfigurations/QuietForwarderGen.cfg ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg
			
			#RAR nov 2019 -- always send forwarder to file (with new trace, verbose mode is handled by trace, no need to printout twice)
			#if [[ $QUIET == 1 ]]; then

				if [ $BACKUPLOGS == 1 ]; then
					DATESTRING=`date +'%s'`
					out "Backing up logfile into ${Yellow}${Bold}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.${DATESTRING}.txt${RstClr}"
					mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.${DATESTRING}.txt
				fi
				
				#out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Message Facility${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt${RstClr}"
				otsConsoleFwd ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg  &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-mf-${THIS_HOST}.txt &
			#else
			#	otsConsoleFwd ${USER_DATA}/MessageFacilityConfigurations/QuietForwarder.cfg  &
			#fi		 	

		fi
		
		if [[ $USE_QT_VIEWER == "1" ]]; then
			out "${Green}${Bold}Launching QT console viewer...${RstClr}"
			if [ "x$ARTDAQ_MFEXTENSIONS_DIR" == "x" ]; then #qtviewer library missing!

				out "${Red}${Bold}Error${RstClr}: ARTDAQ_MFEXTENSIONS_DIR missing for qtviewer!${RstClr}"

				exit
			fi
			
			#start the QT Viewer (only if it is not already started)
			if [ $( ps aux|egrep -c $USER.*msgviewer ) -eq 1 ]; then				
				msgviewer -c ${USER_DATA}/MessageFacilityConfigurations/QTMessageViewerGen.fcl  &
				sleep 2	 #give time for msgviewer to be ready for messages			
			fi		
		fi
	fi
	
	####################################################################
	########### end console & message facility handling ################
	####################################################################
	
	####################################################################
	######################## setup DAQInterface ########################
	####################################################################

	export DAQINTERFACE_PROCESS_MANAGEMENT_METHOD="direct"
	export DAQINTERFACE_FHICL_DIRECTORY=$USER_DATA/ARTDAQConfigurations
	export DAQINTERFACE_KNOWN_BOARDREADERS_LIST=$USER_DATA/ARTDAQConfigurations/known_boardreaders_list

	# Make sure fhicl directory exists
	if ! [ -d $DAQINTERFACE_FHICL_DIRECTORY ]; then
	     if [ ! -L ${DAQINTERFACE_FHICL_DIRECTORY} ]; then
                mkdir -p ${DAQINTERFACE_FHICL_DIRECTORY}
             else
                mkdir -p `readlink -f ${DAQINTERFACE_FHICL_DIRECTORY}`
             fi
	fi
	
	# Create a dummy boardreaders list. 
	# ots will set the components directly, and will not use this file, but DAQInterface requires it to be present.
	if ! [ -e $DAQINTERFACE_KNOWN_BOARDREADERS_LIST ]; then
		echo "component01 localhost" >$DAQINTERFACE_KNOWN_BOARDREADERS_LIST
	fi

	export DAQINTERFACE_SETTINGS=$USER_DATA/ARTDAQConfigurations/daqinterface_settings
	export DAQINTERFACE_USER_SOURCEFILE="IGNORED"
	if [ $ISREMOTE == 0 ]; then
		source $ARTDAQ_DAQINTERFACE_DIR/source_me > /dev/null #hide std output but show errors
	else
		source $ARTDAQ_DAQINTERFACE_DIR/source_me >/dev/null 2>&1 #hide all output when remote (to hide tty warnings)
	fi
	export DAQINTERFACE_SETUP_FHICLCPP=$USER_DATA/ARTDAQConfigurations/.setup_fhiclcpp
			
	####################################################################
	###################### end DAQInterface setup ######################
	####################################################################

	envString="-genv OTSDAQ_LOG_ROOT ${OTSDAQ_LOG_DIR} -genv ARTDAQ_OUTPUT_DIR ${ARTDAQ_OUTPUT_DIR}"



	#create argument to pass to ${xdaqPrefix} xdaq.executable
	export XDAQ_ARGS="${XDAQ_CONFIGURATION_DATA_PATH}/otsConfiguration_CMake.xml -c ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml"
	#out "XDAQ ARGS PASSED TO ${xdaqPrefix} xdaq.exe ${XDAQ_ARGS}${RstClr}"

	value=`cat ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml`	
		
	re="http(s*)://(.+):([0-9]+)"
	superRe="id=\"([0-9]+)\""	
	contextUidRe="ContextUID='(.+)' source"	
		
	haveXDAQContextPort=false
	insideContext=false
	ignore=false
	isLocal=false
	gatewayHostname=""
	gatewayPort=0
	contextUID=""
	gatewayUID=""


	unset xdaqPort #reset
	unset xdaqHost #reset
	unset xdaqLogFilename #reset
	unset xdaqContextUID #reset	
	unset contextHostname #reset (all xdaq context hostnames - maybe with repeats for remote launches, but remote launch loop checks for repeats)
	unset contextPort #reset
	unset contextUIDArray #reset
	unset TempContextPIDArray #reset  
	unset ContextPIDArray #reset

	####################################################################
	########### read from context config and launch Gateway ############
	####################################################################
		
	while read line; do    
		if [[ ($line == *"<!--"*) ]]; then		
			ignore=true
			
			#out "$line ${RstClr}"
			#if a context comment line, extract the context UID
			if [[ ($line =~ $contextUidRe) ]]; then
				contextUID=${BASH_REMATCH[1]}
				
				#out "$contextUID ${RstClr}"
			fi
		fi
		if [[ ($line == *"-->"*) ]]; then
			ignore=false
		fi
		if [[ ${ignore} == true ]]; then
			continue
		fi
		#out "$line${RstClr}"
				
		if [[ ($line == *"xc:Context"*) && ($line == *"url"*) ]]; then
			if [[ ($line =~ $re) ]]; then
				#if https && hostname matches
				#   convert hostname to localhost
				#   create node config files with https:PORT forwarding to localhost:madeupport
				#   run nodejs
				#   run xdaq
			
			
				PORT=${BASH_REMATCH[3]}
				host=${BASH_REMATCH[2]}
				insideContext=true
						
				#out "$host $PORT ${RstClr}"				
						
				if [[ (${BASH_REMATCH[2]} == ${THIS_HOST}) || (${BASH_REMATCH[2]} == ${THIS_HOST}"."*) || (${BASH_REMATCH[2]} == "localhost") ]]; then
				    isLocal=true
				else
				    isLocal=false
				fi

				contextHostname+=(${host})
				contextPort+=(${PORT})
				contextUIDArray+=(${contextUID})
			fi
			#out "------------------------------------------ out"
	
		fi
		if [[ $line == *"/xc:Context"* ]]; then
			insideContext=false
			haveXDAQContextPort=false
			#out "in ------------------------------------------"
		fi
		if [[ ($insideContext == true) ]]; then 
			
			if [[ ($line == *"class"*) ]] && [[ "${isLocal}" == "true" ]]; then #IT'S A LOCAL XDAQ SUPERVISOR		
				
				if [[ ($line == *"ots::GatewaySupervisor"*) ]]; then #IT's the SUPER supervisor, record LID 
					if [[ ($line =~ $superRe) ]]; then
					    gatewayHostname=${host}
						gatewayPort=${PORT}
						gatewayUID=${contextUID}
						
						#echo ${BASH_REMATCH[1]}	#should be supervisor LID
						MAIN_URL="http://${host}:${PORT}/urn:xdaq-application:lid=${BASH_REMATCH[1]}/"
								
						#if gateway launch, do it
						if [[ $ISGATEWAYLAUNCH == 1 && ${host} == ${THIS_HOST} ]]; then						


							####################################################################
							########### 		launch Gateway context	 	 		############
							####################################################################
							
							out #empty line
							
							#cleanup alive files
							rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive* &>/dev/null 2>&1 #hide output #remove alive file


							#attempt to avoid false starts by xdaq by detecting constructor, and relaunching
							rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat >/dev/null 2>&1 #hide output #remove alive file
							OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
							# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
							if [ "$OTS_CONTEXT_UP" != "bad" ]; then
								#sometimes the PORT takes extra time to close
								out "Retrying... Gateway context http PORT is already in use! http://${THIS_HOST}:${PORT}"
								sleep 4
								OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
								# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
								if [ "$OTS_CONTEXT_UP" != "bad" ]; then
									die "Gateway context http PORT is already in use! http://${THIS_HOST}:${PORT}"
								fi
							fi

							if [ $QUIET == 1 ]; then
								info "Launching the Gateway context process on host {${THIS_HOST}}...${RstClr}"								

								if [ $BACKUPLOGS == 1 ]; then
									DATESTRING=`date +'%s'`
									out "Backing up logfile into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.${DATESTRING}.txt${RstClr}"
									mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.${DATESTRING}.txt
								fi
								

								out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Gateway${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt${RstClr}"
								${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt &
							else
								${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &
							fi
							
							LAST_OTS_PID=$!

							if [ $RELAUNCHCHECK == 1 ]; then
							
								#test for relaunch
								# 4 times quietly, then get louder
								
								sleep 2
								OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
								#out "OTS_IS_ALIVE=${OTS_IS_ALIVE}"
								# sleep 10
								
								# Test for start 8 times with short sleep
								for t in {1..8}; do
									if [ "x$OTS_IS_ALIVE" == "x" ]; then		
										sleep 2
										OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
										out "Checking http://${THIS_HOST}:${PORT}..."
									else # found the supervisor!
										# have seen instances where http peer transport xdaq PORT is not established, but xdaq context still is constructed
										# so clear alive, if ots script can not connect to PORT
										OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
										# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
										if [ "$OTS_CONTEXT_UP" == "bad" ]; then
											out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
											OTS_IS_ALIVE=
										fi
										break
									fi
								done								
								
									
								# Alert the user to the problem and keep relaunching

								while [ "x$OTS_IS_ALIVE" == "x" ]; do
									warning "Could not verify successful ots gateway context launch, relaunching ots gateway context..."									
									killproc ${LAST_OTS_PID} 
									sleep 2
									
									if [ $QUIET == 1 ]; then
										out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Gateway${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt${RstClr}"
										
										echo -e "\n\nXDAQ xml:\n\n ${value} \n\n" >> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt
										echo -e "\n\nAttempting restart on extracted host ${THIS_HOST} PORT ${PORT} \n\n" >> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt
										
										${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &>> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-gateway-${THIS_HOST}-${PORT}.txt &
									else
										${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &
									fi
									LAST_OTS_PID=$!
									
									#verify relaunch
									sleep 2
									OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)"
									# Test for start 16 times with short sleep
									for t in {1..16}; do
										if [ "x$OTS_IS_ALIVE" == "x" ]; then		
											sleep 2
											OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
											out "Checking http://${THIS_HOST}:${PORT}..."
										else  # found the supervisor!
											OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
											# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
											if [ "$OTS_CONTEXT_UP" == "bad" ]; then
												out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
												OTS_IS_ALIVE=
											fi
											break
										fi
									done
									
									
									#check if exit requested to avoid endless looping (e.g. on remote hosts)
									OTSDAQ_STARTOTS_ACTION="$(cat ${OTSDAQ_STARTOTS_ACTION_FILE})"
									OTSDAQ_STARTOTS_QUIT="$(cat ${OTSDAQ_STARTOTS_QUIT_FILE})"
									OTSDAQ_STARTOTS_LOCAL_QUIT="$(cat ${OTSDAQ_STARTOTS_LOCAL_QUIT_FILE})"
							
									if [[ "$OTSDAQ_STARTOTS_ACTION" == "KILL_ALL" || "$OTSDAQ_STARTOTS_QUIT" == "KILL_ALL" || "$OTSDAQ_STARTOTS_LOCAL_QUIT" == "KILL_ALL ${THIS_HOST}" ]]; then

										out "Exit of (stale) ots... Action:${OTSDAQ_STARTOTS_ACTION}-Quit:${OTSDAQ_STARTOTS_QUIT}-Local:${OTSDAQ_STARTOTS_LOCAL_QUIT}"
													
										killprocs	

										if [ $ISREMOTE == 1 ]; then
											out "Done killing (stale) processes"
										fi
										
										exit
									fi
									
								done
								
								info "Verified successful ots gateway context ${THIS_HOST}-${PORT} launch..."
							fi
							
							GATEWAY_PID=$LAST_OTS_PID		
							gatewayLogFilename="otsdaq_quiet_run-gateway-${gatewayHostname}-${gatewayPort}.txt"											
							out "Gateway-PID = ${Blue}${Bold}${GATEWAY_PID}${Rev}${RstClr}"
							out #empty line

							
							####################################################################
							########### 		end launch Gateway context	 		############
							####################################################################
						else 
							out "${Orange}${Bold}The gateway context is ${host}-${PORT}, which is not an exact match to this host ${THIS_HOST}!...${RstClr}"
						fi
					fi
				elif [[ ($haveXDAQContextPort == false) && ($gatewayHostname != $host || $gatewayPort != $PORT) ]]; then 
									
					xdaqPort+=($PORT)
					xdaqHost+=($host)	
					xdaqLogFilename+=(otsdaq_quiet_run-${host}-${PORT}.txt)
					xdaqContextUID+=($contextUID)				
					haveXDAQContextPort=true
				fi
 				
			  #IF THERE IS AT LEAST ONE NOT ARTDAQ APP THEN I CAN GET OUT OF THIS CONTEXT AND RUN XDAQ ONCE JUST FOR THIS
			  #insideContext=false #RAR commented because need Super Supervisor connection LID for URL
			  #echo $line          
			fi
		fi   
	done < ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml
		

	####################################################################
	########### 		launch non-Gateway contexts 		############
	####################################################################
		
	if [[ (${#xdaqPort[@]} > 0) ]]; then	
		info "Launching ${#xdaqPort[@]} additional local non-Gateway Context procesess for host {${THIS_HOST}}...${RstClr}"
	else
		out "${Green}${Bold}There are no additional local non-Gateway Context procesess on host {${THIS_HOST}}...${RstClr}"
	fi
	
	i=0	
	for PORT in "${xdaqPort[@]}"
	do
	  : 
	  	#out "${i} ${xdaqPrefix} xdaq.exe -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &"
		  
		if [[ ${xdaqHost[$i]} != ${THIS_HOST} ]]; then
			#out "skipping context not on this host -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &"			
			i=$(( $i + 1 ))
			continue
		fi

		#attempt to avoid false starts by xdaq by detecting constructor, and relaunching
		rm ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat >/dev/null 2>&1 #hide output #remove alive file
		OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
		# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
		if [ "$OTS_CONTEXT_UP" != "bad" ]; then
			#sometimes the PORT takes extra time to close
			out "Retrying... Context '${Bold}${xdaqContextUID[$i]}${RstClr}' http PORT is already in use! http://${THIS_HOST}:${PORT}"
			sleep 4
			OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
			# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
			if [ "$OTS_CONTEXT_UP" != "bad" ]; then
				die "Context http PORT is already in use! http://${THIS_HOST}:${PORT}"
			fi
		fi
		
		if [ $QUIET == 1 ]; then		  

			if [ $BACKUPLOGS == 1 ]; then
				DATESTRING=`date +'%s'`				
				
				out "Backing up logfile to ${Yellow}${Bold}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.${DATESTRING}.txt${RstClr}"				
				mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.${DATESTRING}.txt
			fi
		  			
			out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}${xdaqContextUID[$i]}${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt${RstClr}"			
			${xdaqPrefix} xdaq.exe -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt &
		else
			${xdaqPrefix} xdaq.exe -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &
		fi
		
		LAST_OTS_PID=$!
		
		if [ $ISREMOTE == 0 ]; then
			out "Nongateway-PID = ${Blue}${Bold}${LAST_OTS_PID}${Rev}${RstClr}"
		fi
		
		TempContextPIDArray+=($LAST_OTS_PID)
		ContextPIDArray+=($LAST_OTS_PID)
		
		i=$(( $i + 1 ))
	done
	

	if [ $RELAUNCHCHECK == 1 ]; then
		
		############################################################################
		###########  test for relaunch of local non-Gateway contexts	############
		############################################################################	
		

		# i=0	
		# for PORT in "${xdaqPort[@]}"
		# do
		# 	out "${i} ${xdaqContextUID[$i]} ${xdaqPrefix} INTER -h ${xdaqHost[$i]} -p ${PORT} -pp ${xdaqPort[$i]} &"
		# 	i=$(( $i + 1 ))
		# done

		sleep 1 #give time before relaunch test
		
		unset ContextPIDArray #reset  
		i=0
		j=0
		for PORT in "${xdaqPort[@]}"
		do
		  : 
			#out "${i} ${xdaqContextUID[$i]} ${xdaqPrefix} xdaq.exe -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &"

				  
			if [[ ${xdaqHost[$i]} != ${THIS_HOST} ]]; then
				# out "skipping context not on this host -h ${xdaqHost[$i]} -p ${PORT} -e ${XDAQ_ARGS} &"
				i=$(( $i + 1 ))
				continue
			fi
			
			LAST_OTS_PID=${TempContextPIDArray[$j]}
			
			#test for relaunch
			# 4 times quietly, then get louder		
			
			sleep 2
			OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)
			#out "OTS_IS_ALIVE=${OTS_IS_ALIVE}"
			
			for t in {1..8}; do
				if [ "x$OTS_IS_ALIVE" == "x" ]; then		
					sleep 2
					OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)					
					out "Checking http://${THIS_HOST}:${PORT}..."
				else   # found the supervisor!
					# have seen instances where http peer transport xdaq PORT is not established, but xdaq context still is constructed
					# so clear alive, if ots script can not connect to PORT
					OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
					# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
					if [ "$OTS_CONTEXT_UP" == "bad" ]; then
						out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
						OTS_IS_ALIVE=
					fi
					break
				fi
			done			
			

			while [ "x$OTS_IS_ALIVE" == "x" ]; do
				warning "Could not verify successful ots non-gateway context launch, relaunching non-gateway context..."
				killproc ${LAST_OTS_PID} 
				sleep 2
				
				if [ $QUIET == 1 ]; then					
					out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}${xdaqContextUID[$i]}${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt${RstClr}"
					echo -e "\n\nXDAQ xml:\n\n ${value} \n\n" >> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt
					echo -e "\n\nAttempting restart on extracted host '${THIS_HOST}' PORT ${PORT} \n\n" >>  ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt
					${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &>> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-${THIS_HOST}-${PORT}.txt &
				else
					${xdaqPrefix} xdaq.exe -h ${THIS_HOST} -p ${PORT} -e ${XDAQ_ARGS} &
				fi
				LAST_OTS_PID=$!
				
				if [ $ISREMOTE == 0 ]; then
					out "Nongateway-PID = ${Blue}${Bold}${LAST_OTS_PID}${Rev}${RstClr}"
				fi
				
				#test for relaunch
				sleep 2
				OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)"
				for t in {1..16}; do
					if [ "x$OTS_IS_ALIVE" == "x" ]; then		
						sleep 2
						OTS_IS_ALIVE="$(cat ${OTSDAQ_LOG_DIR}/otsdaq_is_alive-${THIS_HOST}-${PORT}.dat 2>/dev/null)" #hide error messages, but not std out (std out is needed!)					
						out "Checking http://${THIS_HOST}:${PORT}..."
					else   # found the supervisor!
						OTS_CONTEXT_UP="$(curl -m 3 http://${THIS_HOST}:${PORT} >/dev/null 2>&1 || echo 'bad')" #detect if http server has gone up
						# out "OTS_CONTEXT_UP=${OTS_CONTEXT_UP}"
						if [ "$OTS_CONTEXT_UP" == "bad" ]; then
							out "Context http PORT could not be verified at curl http://${THIS_HOST}:${PORT} >/dev/null 2>&1"
							OTS_IS_ALIVE=
						fi
						break
					fi
				done

				
				
				#check if exit requested to avoid endless looping (e.g. on remote hosts)
				OTSDAQ_STARTOTS_ACTION="$(cat ${OTSDAQ_STARTOTS_ACTION_FILE})"
				OTSDAQ_STARTOTS_QUIT="$(cat ${OTSDAQ_STARTOTS_QUIT_FILE})"
				OTSDAQ_STARTOTS_LOCAL_QUIT="$(cat ${OTSDAQ_STARTOTS_LOCAL_QUIT_FILE})"
		
				if [[ "$OTSDAQ_STARTOTS_ACTION" == "KILL_ALL" || "$OTSDAQ_STARTOTS_QUIT" == "KILL_ALL" || "$OTSDAQ_STARTOTS_LOCAL_QUIT" == "KILL_ALL ${THIS_HOST}" ]]; then

					out "Exit of (stale) ots... Action:${OTSDAQ_STARTOTS_ACTION}-Quit:${OTSDAQ_STARTOTS_QUIT}-Local:${OTSDAQ_STARTOTS_LOCAL_QUIT}"
								
					killprocs	

					if [ $ISREMOTE == 1 ]; then
						out "Done killing (stale) processes"
					fi
					
					exit
				fi
			done 		
			
			info "Verified successful ots non-gateway context ${THIS_HOST}-${PORT} launch."
			#add successful launch to Context PID array	
			ContextPIDArray+=($LAST_OTS_PID)
			#ContextPIDArray+=(${TempContextPIDArray[$j]})
			
			
			i=$(( $i + 1 ))
			j=$(( $j + 1 ))
		done #end test for relaunch loop
		####################################################################
		
		
	fi #end local relaunch checking
	####################################################################
	
	if [[ $REMOTELAUNCH == 1 && (${#contextHostname[@]} > 1) ]]; then
		############################################################################
		########### 	   Lunch of remote non-Gateway contexts			############
		############################################################################	
		
		remoteHostCount=$((${#contextHostname[@]} -1 - ${#xdaqPort[@]}))
		
		unset remoteLaunchHosts
		
		out #blank line
		info "Launching ${remoteHostCount} remote host otsdaq Context procesess (to disable remote start, use ots -s)...${RstClr}"
		
		for host in "${contextHostname[@]}"
		do
		  : 
		  				  
			if [[ ${host} != ${THIS_HOST} ]]; then
			
				#first check that we have not done a remote launch on host already
				j=0
				alreadyLaunched=0
				for launchedHost in "${remoteLaunchHosts[@]}"
				do						
					if [[ ${host} == ${launchedHost} ]]; then
						alreadyLaunched=1
						break
					fi
				done	
			
				#skip all repeating hostnames
				if [[ $alreadyLaunched == 1 ]]; then
					continue;
				fi
			
				out "\tRemote launch of ots Context processes on host {${host}}."
				out "\t\tssh ${host} ${SCRIPT_DIR}/ots_remote_start" 
				
				# launch ssh remote start (attempt twice)
				ssh ${host} ${SCRIPT_DIR}/ots_remote_start ${host} || ssh ${host} ${SCRIPT_DIR}/ots_remote_start ${host} || out "${Red}${REV} ***************** {${host}} Remote start failed (check local permissions and remote installation)! ********************* ${RstClr}" &
				
				
				#add host to remote launch host list
				remoteLaunchHosts+=(${host})					
			fi
		done
		
							
	
	fi #end remote launch handling
	####################################################################
	
	#if [ $ISREMOTE == 0 ]; then
	#	out "Done launching ots Context processes."
	#fi
	
	# Done launching ots contexts
	####################################################################
	

	FIRST_TIME=0 #used to supress printouts
		
	#if [ $ISREMOTE == 0 ]; then
	#	out "Note: This host is ${THIS_HOST}."
	#fi
	
	# if [[ (${#xdaqPort[@]} != 0) && "x${gatewayHostname}" != "x" ]]; then
	# 	out
	# 	out "These are the hosts configured to run ots Context processes: ${contextHostname[@]}"
	# 	out "These are the corresponding ports for the Context processes: ${contextPort[@]}"
	# 	out "These are the corresponding UIDs for the Context processes:  ${contextUIDArray[@]}"
	# 	out  
	# fi
	

	  
	if [[ (${#xdaqPort[@]} == 0) && $gatewayHostname != ${THIS_HOST} ]]; then
		out "${Yellow}${Bold}************************************************************************************${RstClr}"
		out "${Yellow}${Bold}************************************************************************************${RstClr}"
		
		out "${Red}${Bold}${Blink}WARNING${RstClr}: There are no configured processes for hostname ${THIS_HOST}." 
		out "Are you sure your configuration is written for ${Red}${Bold}${Blink}${THIS_HOST}${RstClr}?" 
		out
		out "These are the hosts configured to run ots Context processes: ${contextHostname[@]}"
		out "These are the corresponding ports for the Context processes: ${contextPort[@]}"
		out "These are the corresponding UIDs for the Context processes:  ${contextUIDArray[@]}"
		out  
		out "You can change the configuration for ${THIS_HOST} in wiz mode by..."
		out "\tGoing to the Configure App   -> click 'Tree-View' next to Active-Context"
		out "\t-> expand 'XDAQContextTable' -> change 'Address' to set desired host name."
		
		out "${Yellow}${Bold}************************************************************************************${RstClr}"
		out "${Yellow}${Bold}************************************************************************************${RstClr}"
		
	elif [[ $ISGATEWAYLAUNCH == 1 ]]; then
		printMainURL &	
	fi
	
	
}   #end launchOTS
export -f launchOTS

launchOTSLogFind() {
	

	##############################################################################
	XDAQ_OTS_XML="ots" 	#used for normal mode launch as copy location for stable script launching
	##############################################################################
	
	out #blank line
	out "${Purple}${REV}                                                                         ${RstClr}"
	out "${Purple}${REV} *********************************************************************** ${RstClr}"
	out "${Purple}${REV} ***********       Finding potential ots log files!         ************ ${RstClr}"
	out "${Purple}${REV} *********************************************************************** ${RstClr}"
	out "${Purple}${REV}                                                                         ${RstClr}"
	out #blank line
	out "XDAQ Configuration XML   = ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml"	
	
	value=`cat ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml`	
		
	re="http(s*)://(.+):([0-9]+)"
	superRe="id=\"([0-9]+)\""	
	contextUidRe="ContextUID='(.+)' source"	
		
	haveXDAQContextPort=false
	insideContext=false
	ignore=false
	isLocal=false
	gatewayHostname=""
	gatewayPort=0
	contextUID=""
	gatewayUID=""

	unset xdaqPort #reset
	unset xdaqHost #reset
	unset xdaqContextUID #reset	
	unset contextHostname #reset (a Set of hostnames only for remove launches)	
	unset TempContextPIDArray #reset  
	unset ContextPIDArray #reset

	####################################################################
	########### read from context config and launch Gateway ############
	####################################################################
		
	while read line; do    
		if [[ ($line == *"<!--"*) ]]; then		
			ignore=true
			
			#out "$line ${RstClr}"
			#if a context comment line, extract the context UID
			if [[ ($line =~ $contextUidRe) ]]; then
				contextUID=${BASH_REMATCH[1]}
				
				# out "$contextUID ${RstClr}"
			fi
		fi
		if [[ ($line == *"-->"*) ]]; then
			ignore=false
		fi
		if [[ ${ignore} == true ]]; then
			continue
		fi
		#out "$line${RstClr}"
				
		if [[ ($line == *"xc:Context"*) && ($line == *"url"*) ]]; then
			if [[ ($line =~ $re) ]]; then
				#if https && hostname matches
				#   convert hostname to localhost
				#   create node config files with https:PORT forwarding to localhost:madeupport
				#   run nodejs
				#   run xdaq
			
				PORT=${BASH_REMATCH[3]}
				host=${BASH_REMATCH[2]}
				insideContext=true
						
				if [[ (${BASH_REMATCH[2]} == ${THIS_HOST}) || (${BASH_REMATCH[2]} == ${THIS_HOST}"."*) || (${BASH_REMATCH[2]} == "localhost") ]]; then
				    isLocal=true
				else
				    isLocal=false
				fi
				# out "$host $PORT $isLocal ${RstClr}"	

				if [[ ${contextHostname[*]} != ${BASH_REMATCH[2]} ]]; then
					contextHostname+=(${BASH_REMATCH[2]})
					# out "$contextUID"
				fi
			fi
			#out "------------------------------------------ out"
	
		fi
		if [[ $line == *"/xc:Context"* ]]; then
			insideContext=false
			haveXDAQContextPort=false
			#out "in ------------------------------------------"
		fi
		if [[ ($insideContext == true) ]]; then 
			
			if [[ ($line == *"class"*) ]] ; then #IT'S A XDAQ SUPERVISOR		
				
				if [[ ($line == *"ots::GatewaySupervisor"*) ]]; then #IT's the SUPER supervisor, record LID 
					if [[ ($line =~ $superRe) ]]; then

					    gatewayHostname=${host}
						gatewayPort=${PORT}
						gatewayUID=${contextUID}
						fn="otsdaq_quiet_run-gateway-${host}-${PORT}"
						out "${Red}${Bold}Log file for gateway${RstClr} '${Bold}${contextUID}${RstClr}' on host${RstClr} '${Bold}${host}${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			

					fi
				elif [[ ($haveXDAQContextPort == false) && ($gatewayHostname != $host || $gatewayPort != $PORT) ]]; then 
									
					xdaqPort+=($PORT)
					xdaqHost+=($host)	
					xdaqContextUID+=($contextUID)				
					haveXDAQContextPort=true
					# out "$contextUID"
					fn="otsdaq_quiet_run-${host}-${PORT}"
					out "${Red}${Bold}Log file for${RstClr} '${Bold}${contextUID}${RstClr}' on host${RstClr} '${Bold}${host}${RstClr}' output into ${Yellow}${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			
				fi
 				
			  #IF THERE IS AT LEAST ONE NOT ARTDAQ APP THEN I CAN GET OUT OF THIS CONTEXT AND RUN XDAQ ONCE JUST FOR THIS
			  #insideContext=false #RAR commented because need Super Supervisor connection LID for URL
			  #echo $line          
			fi
		fi   
	done < ${XDAQ_CONFIGURATION_DATA_PATH}/${XDAQ_OTS_XML}.xml
			

	out #blank line
	out "Here are example commands for viewing all potential log files:"
	out #blank line

	fn="otsdaq_quiet_run-gateway-${gatewayHostname[$i]}-${gatewayPort}"
	if [[ ${gatewayHostname[$i]} != ${THIS_HOST} ]]; then
		out "   vless_mu2e.sh ${gatewayHostname[$i]} ${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			
	else
		out "   less ${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			
	fi

	#non-gateway contexts
	i=0	
	for PORT in "${xdaqPort[@]}"
	do
		: 

		fn="otsdaq_quiet_run-${xdaqHost[$i]}-${PORT}"

		# out "[$i] == $fn - ${xdaqHost[$i]} - ${PORT} - $gatewayHostname : $gatewayPort"

		if [[ ${xdaqHost[$i]} != ${THIS_HOST} ]]; then
			out "   vless_mu2e.sh ${Bold}${xdaqHost[$i]}${RstClr} ${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			
		else
			out "   less ${OTSDAQ_LOG_DIR}/${fn}.txt${RstClr}"			
		fi
		i=$(( $i + 1 ))
	done
	out #blank line

	# out #blank line
	# out "These are the hosts configured to run ots Context processes: ${gatewayHostname} ${xdaqHost[@]}"
	# out "These are the corresponding ports for the Context processes: ${gatewayPort} ${xdaqPort[@]}"
	# out "These are the corresponding UIDs for the Context processes:  ${gatewayUID} ${xdaqContextUID[@]}"
	# out #blank line	
	
}   #end launchOTSLogFind
export -f launchOTSLogFind

#########################################################
#########################################################

#make URL print out a function so that & syntax can be used to run in background (user has immediate terminal access)
printMainURL() {	
	
	#out "printMainURL()"
		
	if [ $QUIET == 0 ]; then
		sleep 5 #give a little more time before injecting printouts in scrolling printouts
	else
		sleep 4 #give a little time for other StartOTS printouts to occur (so this one is last)  
	fi
	
	echo #empty line
	echo #empty line
	
	if [ $MAIN_URL == "unknown_url" ]; then
		if [ $ISREMOTE == 0 ]; then
			out "INFO: No gateway supervisor found for node {${THIS_HOST}}.${RstClr}"
		fi
		exit
	fi
	

	out "Open the URL below in your Google Chrome or Mozilla Firefox web browser:"	
	out "\t(Note: This URL may need to be modified depending on your network configuration)"
		
	for t in {1..5}
	do		
		out "${Green}${Bold}${EUNDERLINE}${MAIN_URL}${RstClr}"

		#echo -e "${Reset}"
		
		if [ $QUIET == 1 ]; then
			exit
		fi
		sleep 2 #for delay between each printout
	done
}  #end printMainURL
export -f printMainURL


#########################################################
#########################################################
otsActionHandler() {

	info "Starting action handler on {${THIS_HOST}}..."

	if [[ ($ISCONFIG == 1) || ("${THIS_HOST}" == "${gatewayHostname}") ]]; then
		out "The script, on ${THIS_HOST}, is the gateway ots script, so it will drive the exit of ots scripts running on other hosts."

		if [ $REMOTELAUNCH == 1 ]; then #only kill other ots scripts if remote launch was enabled
			echo "EXIT_LOOP" > $OTSDAQ_STARTOTS_QUIT_FILE
		fi
		
		echo "EXIT_LOOP ${THIS_HOST}" > $OTSDAQ_STARTOTS_LOCAL_QUIT_FILE
		
		#time for other stale StartOTS to quit
		sleep 5
		
		#clear files initially
		echo "0" > $OTSDAQ_STARTOTS_ACTION_FILE
		echo "0" > $OTSDAQ_STARTOTS_QUIT_FILE
		echo "0" > $OTSDAQ_STARTOTS_LOCAL_QUIT_FILE
	else
		sleep 10 #non gateways sleep for a while, to give time to quit stale scripts
		
		#clear files initially
		echo "0" > $OTSDAQ_STARTOTS_ACTION_FILE
		echo "0" > $OTSDAQ_STARTOTS_LOCAL_QUIT_FILE 
	fi	
		
	FIRST_TIME=1 #to enable url printouts
	
	#listen for file commands
	while true; do
		#In OTSDAQ_STARTOTS_ACTION_FILE
		#0 is the default. No action is taken
		#REBUILD_OTS will rebuild otsdaq
		#Reset_MPI will reboot artdaq MPI runs
		#EXIT_LOOP will exit ots action loop
		#KILL_ALL will kill all and exit ots action loop
		#if cmd file is missing, exit StartOTS loop
		
		OTSDAQ_STARTOTS_ACTION="$(cat ${OTSDAQ_STARTOTS_ACTION_FILE})"
		OTSDAQ_STARTOTS_QUIT="$(cat ${OTSDAQ_STARTOTS_QUIT_FILE})"
		OTSDAQ_STARTOTS_LOCAL_QUIT="$(cat ${OTSDAQ_STARTOTS_LOCAL_QUIT_FILE})"
		
		echo "0" > $OTSDAQ_STARTOTS_ACTION_FILE #clear the command in the file; it has been responded to
				
		#out "message loop command ${OTSDAQ_STARTOTS_ACTION} ${OTSDAQ_STARTOTS_QUIT} ${OTSDAQ_STARTOTS_LOCAL_QUIT} "
				
		if [ "$OTSDAQ_STARTOTS_ACTION" == "REBUILD_OTS" ]; then
		

			out " "
			out "Rebuilding..."
			out " "			
			#echo "1" > mrbresult.num; mrb b > otsdaq_startots_mrbreport.txt && echo "0" > mrbresult.num			
			out " "
			#grep -A 1 -B 1 "INFO: Stage build successful." otsdaq_startots_mrbreport.txt
			out " "
			sleep 5
		
		elif [ "$OTSDAQ_STARTOTS_ACTION" == "OTS_APP_SHUTDOWN" ]; then
		

			out " "
			out "Shutting down non-gateway contexts..."
			out " "	
			
			#kill all non-Gateway context processes
			killprocs nongateway
			
		elif [ "$OTSDAQ_STARTOTS_ACTION" == "OTS_APP_STARTUP" ]; then
		

			out " "
			out "Starting up non-gateway contexts..."
			out " "	
			
			#prevent remote ssh launches
			TMP_REMOTELAUNCH=$REMOTELAUNCH
			REMOTELAUNCH=0
			launchOTS nongateway #launch all non-gateway apps	
			REMOTELAUNCH=$TMP_REMOTELAUNCH	
	
		elif [ "$OTSDAQ_STARTOTS_ACTION" == "LAUNCH_WIZ" ]; then
			

			out "Starting otsdaq Wiz mode for host {${THIS_HOST}}..."

			killprocs
			
			launchOTSWiz
			
			#sleep 1 #so that the terminal comes back after the printouts in quiet mode
			
			FIRST_TIME=1 #re-enable printouts for launch ots, in case of context changes

		elif [ "$OTSDAQ_STARTOTS_ACTION" == "LAUNCH_OTS" ]; then

			out "Starting otsdaq in normal mode for host {${THIS_HOST}}..."

			killprocs
			
			launchOTS

			#wait #so that the terminal comes back after the printouts in quiet mode			

		elif [ "$OTSDAQ_STARTOTS_ACTION" == "FLATTEN_TO_SYSTEM_ALIASES" ]; then

			out "Removing unused tables and groups based on active System Aliases..."			
			out "otsdaq_flatten_system_aliases 0"
			

			if [ $QUIET == 1 ]; then			

				if [ $BACKUPLOGS == 1 ]; then
					DATESTRING=`date +'%s'`
					out "     Backing up logfile to *** ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-flatten-${THIS_HOST}.${DATESTRING}.txt ***"
					mv ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-flatten-${THIS_HOST}.txt ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-flatten-${THIS_HOST}.${DATESTRING}.txt
				fi
				
				out "${Red}${Bold}Quiet mode${RstClr}. '${Bold}Flattening${RstClr}' output into ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-flatten-${THIS_HOST}.txt ***  "	
				otsdaq_flatten_system_aliases 0 &> ${OTSDAQ_LOG_DIR}/otsdaq_quiet_run-flatten-${THIS_HOST}.txt &
			else
				otsdaq_flatten_system_aliases 0 &
			fi		
						
		elif [[ "$OTSDAQ_STARTOTS_ACTION" == "EXIT_LOOP" || "$OTSDAQ_STARTOTS_QUIT" == "EXIT_LOOP" || "$OTSDAQ_STARTOTS_LOCAL_QUIT" == "EXIT_LOOP ${THIS_HOST}" ]]; then

			#only exit action loop
			out "Exit of (stale) ots... Action:${OTSDAQ_STARTOTS_ACTION}-Quit:${OTSDAQ_STARTOTS_QUIT}-Local:${OTSDAQ_STARTOTS_LOCAL_QUIT}"
			
		    exit

		elif [[ "$OTSDAQ_STARTOTS_ACTION" == "KILL_ALL" || "$OTSDAQ_STARTOTS_QUIT" == "KILL_ALL" || "$OTSDAQ_STARTOTS_LOCAL_QUIT" == "KILL_ALL ${THIS_HOST}" ]]; then

			#kill all and exit action loop
			out "Exit of (stale) ots... Action:${OTSDAQ_STARTOTS_ACTION}-Quit:${OTSDAQ_STARTOTS_QUIT}-Local:${OTSDAQ_STARTOTS_LOCAL_QUIT}"
						
			killprocs ownedProcesses #do not call killall and kill whichever process asked for kill

			if [ $ISREMOTE == 1 ]; then
				out "Done killing (stale) processes"
			fi
			
		    exit
			
		elif [[ "${OTSDAQ_STARTOTS_ACTION:-"0"}" != "0"  || "${OTSDAQ_STARTOTS_QUIT:-"0"}" != "0" ]]; then
		
			out "Exiting ots.. Unrecognized command !=0 in Action:${OTSDAQ_STARTOTS_ACTION}-Quit:${OTSDAQ_STARTOTS_QUIT}-Local:${OTSDAQ_STARTOTS_LOCAL_QUIT}"			
			exit
			
		fi
				
		sleep 1

		#manage log file rollover
		if [ "x$OTS_LOG_ROLLOVER" != "x" ]; then
			i=0
			for contextPID in "${ContextPIDArray[@]}"
			do
				if [[ ${xdaqHost[$i]} != ${THIS_HOST} ]]; then
					i=$(( $i + 1 ))
					continue
				fi

				logFileSize=$(stat -c %s "${OTSDAQ_LOG_DIR}/${xdaqLogFilename[$i]}")
				if [ "x$logFileSize" == "x" ]; then
					logFileSize=0
					# out "File empty"
				fi
				# out "${Red}${Rev}Found Non-gateway process ID ${contextPID} -h ${xdaqHost[$i]} -p ${PORT} > ${xdaqLogFilename[$i]} size=${logFileSize} ${RstClr}"

				# if log file > 100MB
				if [ $logFileSize -gt 100000000 ]; then 
					DATESTRING=`date +'%s'`	
					xdaqLogFilename[$i]="otsdaq_quiet_run-gateway-${gatewayHostname}-${gatewayPort}-${DATESTRING}.txt"
					
					#from https://github.com/jerome-pouiller/reredirect/
					reredirect -m "${OTSDAQ_LOG_DIR}/${xdaqLogFilename[$i]}" ${GATEWAY_PID}
					out "${Red}${Rev}Doing log rollover of Non-gateway process ID ${contextPID} -h ${xdaqHost[$i]} -p ${PORT} > ${xdaqLogFilename[$i]}${RstClr}"
				fi
			done

			if [[ -v GATEWAY_PID ]]; then
				logFileSize=$(stat -c %s "${OTSDAQ_LOG_DIR}/${gatewayLogFilename}")
				if [ "x$logFileSize" == "x" ]; then
					logFileSize=0
					# out "File empty"
				fi
				# out "${Red}${Rev}Found Gateway process ID ${GATEWAY_PID} -h ${gatewayHostname} -p ${gatewayPort} > ${gatewayLogFilename} size=${logFileSize} ${RstClr}"
				
				# if log file > 100MB
				if [ $logFileSize -gt 100000000 ]; then 
					DATESTRING=`date +'%s'`	
					gatewayLogFilename="otsdaq_quiet_run-gateway-${gatewayHostname}-${gatewayPort}-${DATESTRING}.txt"
					
					#from https://github.com/jerome-pouiller/reredirect/
					reredirect -m "${OTSDAQ_LOG_DIR}/${gatewayLogFilename}" ${GATEWAY_PID}
					out "${Red}${Rev}Doing log rollover of Gateway process ID ${GATEWAY_PID} -h ${gatewayHostname} -p ${gatewayPort} > ${gatewayLogFilename}${RstClr}"
				fi
			fi
		fi

	done

		
} #end otsActionHandler
export -f otsActionHandler

#functions have been declared
#now launch things


if [ $ISFINDLOGFILES == 1 ]; then
	launchOTSLogFind
	exit
fi

#exit any old action loops (do not exit for just displaying log files, above)
echo "EXIT_LOOP" > $OTSDAQ_STARTOTS_ACTION_FILE

if [ $ISREMOTE == 0 ]; then
	out #blank line
fi

if [ $ISMACROMAKER == 1 ]; then
	launchOTSMacromaker $1 $2 $3
	exit
elif [ $ISCONFIG == 1 ]; then
	launchOTSWiz
else
	launchOTS  #only launch gateway once.. on shutdown and startup others can relaunch
fi

if [ $ISREMOTE == 0 ]; then
	out #blank line
fi

sleep 2 #attempt to avoid false starts by xdaq 
#after gateway node has been decided and xdaq has been launched, start action handler
exec
otsActionHandler &

#exec >/dev/null 2>&1 </dev/null # output redirections stop getting a SIGTTOU when run remotely which will kill us

#launch chrome here if enabled
if [ $CHROME == 1 ]; then
	sleep 3 #give time for server to be alive
	google-chrome $MAIN_URL &
fi

#launch firefox here if enabled
if [ $FIREFOX == 1 ]; then
	sleep 3 #give time for server to be alive
	firefox $MAIN_URL &
fi

#sleep 5 #so that the terminal comes back after the printouts are done ( in quiet mode )

# This does all we really needed from reset


